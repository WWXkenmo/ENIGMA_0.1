#' @title ENIGMA trace norm version
#'
#' @param object ENIGMA object
#'
#' @param alpha
#' ENIGMA is a multi-objective optimization problem involve two object function,
#' the distance function between observed bulk RNA-seq and reconstitute RNA-seq
#' generated by weighted combination of CSE, and the distance function beween
#' average CSE expression and cell type reference matrix. The alpha is used to
#' determine weights of these two objects. If the alpha gets larger,
#' the optimization attach greater importance on the the first object.
#' Default: 0.5
#'
#' @param beta
#' This parameter is used to control the latent dimension of each CSE,
#' if this parameter gets larger, than the latent dimension of each CSE is smaller
#' (lower trace norm value), which means that each sample is more similar with
#' each others. The user need to tune this parameter based on the range of
#' the singular value of the bulk RNA-seq matrix.
#' Default: 100
#'
#' @param gamma
#' This parameter is used to control the distance between CSE (X) and auxiliary variable (Y). Default: 1
#'
#' @param epsilon
#' In trace norm based ENIGMA, the epsilon is not necessarily choose
#' a extremly small value, the number of iteration would influence
#' the latent dimensions of CSE, as each step is performing singular value thresholding.
#' Default: 0.0001
#'
#' @param max.iter
#' The maximum number of iterations. Default: 100
#'
#' @param verbose
#' Whether return the information after each step of processing. Default: TRUE
#'
#' @param Normalize
#' Whether perform normalization on resulted expression profile. Default: TRUE
#'
#' @param Norm.method
#' Method used to perform normalization. User could choose PC or frac.
#' 
#' @param preprocess
#' Method used to perform variance stablization preprocessing. User could choose var or log.
#'
#' @export
#'
ENIGMA_trace_norm <- function(object, alpha=0.5, beta=100, gamma=1, epsilon=0.0001, max.iter=100, verbose=TRUE, Normalize = TRUE, Norm.method = "PC",preprocess = "var"){
    if(preprocess == "var") O = sqrt(object@bulk)
	if(preprocess == "log") O = log2(object@bulk+1)
	
    theta = object@result_cell_proportion
    R = sqrt(object@ref)

    X = array(0,
              dim = c( nrow(O),
                       ncol(O),
                       ncol(theta)),
              dimnames = list( rownames(O),
                               colnames(O),
                               colnames(theta))
    )
    for(i in 1:ncol(theta)){
        X[,,i] <- O
    }

    ###
    A <- Y <- X
    A_k_1 <- A_k <- A
    Y_k_1 <- Y_k <- Y
    X_k_1 <- X_k <- X
    a <- as.matrix(rep(1/nrow(theta), nrow(theta)))

    #calculate F matrix
    F = array(0,
              dim = c( ncol(O),
                       ncol(O),
                       ncol(theta)),
              dimnames = list( colnames(O),
                               colnames(O),
                               colnames(theta))
    )
    for(i in 1:ncol(theta)){F[,,i] <- getF(theta[,i],alpha,gamma,a)}
    theta_hat <- colMeans(theta)
    k <- 0
    delta <- 10000
    repeat{
        if(abs(delta)<epsilon||k>max.iter){
            break;
        }else{
            # update
            X_k <- X_k_1
            Y_k <- Y_k_1
            A_k <- A_k_1

            ratio <- NULL
            for(j in 1:ncol(theta)){
                #a <- as.matrix(a.m[j,])
                T_k_j <- getT(j,X_k,theta,O,alpha)
                X_k_1[,,j] <- ((1-alpha)*as.matrix(R[,j])%*%t(a) - A_k[,,j] + gamma*Y_k[,,j] - T_k_j)%*%F[,,j]
                Y_k_1[,,j] <- SVT(((A_k[,,j]/gamma)+X_k_1[,,j]),(beta*theta_hat[j])/gamma)

                A_k_1[,,j] <- A_k[,,j] + gamma*(X_k_1[,,j]-Y_k_1[,,j])
                ratio <- c(ratio, sum( (X_k_1[,,j]-X_k[,,j])^2 )/sum(X_k[,,j]^2))
            }

            if(verbose) writeLines( sprintf("   Ratio ranges from: %f - %f", min(ratio), max(ratio) ) )
            r <- loss(O,X_k,theta,alpha,beta,R)
            if(verbose) writeLines( sprintf("   Loss: part1=%f , part2=%f , part3=%f", r$part1,r$part2,r$part3 ) )
            delta <- max(ratio)
            k <- k+1
        }
    }
	
    writeLines( paste("Converge in ",k," steps",sep="") )
	
	if(Normalize){
	cat("Perform Normalization...")
	if(Norm.method == "PC"){
	X_k_norm <- X_k
	for(k in 1:dims(X_k)[3]){
	   if(preprocess == "var") exp <- X_k[,,k]^2
	   if(preprocess == "log") exp <- 2^X_k[,,k] - 1
	   exp.scale <- t(apply(exp,1,scale))
	   PC <- svd(exp.scale)$v[,1]
	   exp.norm <- NULL
	   for(i in 1:nrow(exp)){
	      lm.model <- lm(exp[i,]~PC)
		  exp.norm <- rbind(exp.norm, (exp[i,] - lm.model$coefficients[2] * PC))
	   }
	   X_k_norm[,,k] <- exp.norm
	}
	}
	
	if(Norm.method == "frac"){
	X_k_norm <- X_k
	for(k in 1:dims(X_k)[3]){
	   if(preprocess == "var") exp <- X_k[,,k]^2
	   if(preprocess == "log") exp <- 2^X_k[,,k] - 1
	   exp <- X_k[,,k]^2
	   exp.norm <- NULL
	   for(i in 1:nrow(exp)){
	      lm.model <- lm(exp[i,]~theta[,k])
		  exp.norm <- rbind(exp.norm, (exp[i,] - lm.model$coefficients[2] * theta[,k]))
	   }
	   X_k_norm[,,k] <- exp.norm
	}
	}
	object@result_CSE_normalized <- res2sce(X_k_norm)
	}
    if(preprocess == "var") object@result_CSE = res2sce(X_k^2)
	if(preprocess == "log") object@result_CSE = res2sce(2^X_k - 1)
    return(object)
}

#Using nuclear norm to regularize the object function
getF <- function(theta,alpha,gamma,a){
    F_val <- alpha*diag(theta^2)+(1-alpha)*a%*%t(a)+gamma*diag(length(a))
    F_val <- solve(F_val)
    F_val
}

getT <- function(index,X,theta_m,O,alpha){
    X_summary <- 0;
    cell_type_seq <- c(1:ncol(theta_m))
    cell_type_seq <- cell_type_seq[cell_type_seq!=index]

    for(i in cell_type_seq){
        X_summary <- X_summary + X[,,i]%*%diag(theta_m[,i])
    }

    T_val <- alpha*(X_summary-O)%*%diag(theta_m[,index])
    T_val
}

SVT <- function(Mat,t){
    svd <- svd(Mat)
    d <- svd$d
    d <- d - t
    d[d<0] <- 0
    Mat_t <- svd$u %*% diag(d) %*% t(svd$v)
    Mat_t
}